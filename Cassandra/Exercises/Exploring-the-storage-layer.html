<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">.lst-kix_d8sp4n4f5mhc-0>li:before{content:"\0025cf  "}.lst-kix_6c5gtkz4c1ey-1>li:before{content:"\0025cb  "}.lst-kix_6c5gtkz4c1ey-3>li:before{content:"\0025cf  "}.lst-kix_d8sp4n4f5mhc-1>li:before{content:"\0025cb  "}.lst-kix_6c5gtkz4c1ey-2>li:before{content:"\0025a0  "}.lst-kix_6c5gtkz4c1ey-6>li:before{content:"\0025cf  "}ul.lst-kix_uic5vdihm6c5-2{list-style-type:none}.lst-kix_d8sp4n4f5mhc-3>li:before{content:"\0025cf  "}ul.lst-kix_uic5vdihm6c5-1{list-style-type:none}ul.lst-kix_uic5vdihm6c5-0{list-style-type:none}.lst-kix_d8sp4n4f5mhc-2>li:before{content:"\0025a0  "}.lst-kix_d8sp4n4f5mhc-4>li:before{content:"\0025cb  "}.lst-kix_6c5gtkz4c1ey-5>li:before{content:"\0025a0  "}.lst-kix_6c5gtkz4c1ey-4>li:before{content:"\0025cb  "}.lst-kix_d8sp4n4f5mhc-7>li:before{content:"\0025cb  "}ul.lst-kix_uic5vdihm6c5-8{list-style-type:none}.lst-kix_d8sp4n4f5mhc-6>li:before{content:"\0025cf  "}.lst-kix_d8sp4n4f5mhc-8>li:before{content:"\0025a0  "}ul.lst-kix_uic5vdihm6c5-7{list-style-type:none}ul.lst-kix_uic5vdihm6c5-6{list-style-type:none}.lst-kix_d8sp4n4f5mhc-5>li:before{content:"\0025a0  "}ul.lst-kix_uic5vdihm6c5-5{list-style-type:none}ul.lst-kix_uic5vdihm6c5-4{list-style-type:none}ul.lst-kix_uic5vdihm6c5-3{list-style-type:none}.lst-kix_6c5gtkz4c1ey-7>li:before{content:"\0025cb  "}.lst-kix_6c5gtkz4c1ey-8>li:before{content:"\0025a0  "}.lst-kix_o30a3m8slal0-1>li:before{content:"\0025cb  "}.lst-kix_o30a3m8slal0-0>li:before{content:"\0025cf  "}.lst-kix_o30a3m8slal0-2>li:before{content:"\0025a0  "}ul.lst-kix_d8sp4n4f5mhc-6{list-style-type:none}ul.lst-kix_o30a3m8slal0-1{list-style-type:none}ul.lst-kix_d8sp4n4f5mhc-5{list-style-type:none}ul.lst-kix_o30a3m8slal0-0{list-style-type:none}ul.lst-kix_d8sp4n4f5mhc-8{list-style-type:none}ul.lst-kix_d8sp4n4f5mhc-7{list-style-type:none}ul.lst-kix_d8sp4n4f5mhc-2{list-style-type:none}ul.lst-kix_o30a3m8slal0-5{list-style-type:none}ul.lst-kix_d8sp4n4f5mhc-1{list-style-type:none}ul.lst-kix_o30a3m8slal0-4{list-style-type:none}ul.lst-kix_d8sp4n4f5mhc-4{list-style-type:none}ul.lst-kix_o30a3m8slal0-3{list-style-type:none}ul.lst-kix_d8sp4n4f5mhc-3{list-style-type:none}ul.lst-kix_o30a3m8slal0-2{list-style-type:none}ul.lst-kix_o30a3m8slal0-8{list-style-type:none}ul.lst-kix_o30a3m8slal0-7{list-style-type:none}.lst-kix_o30a3m8slal0-8>li:before{content:"\0025a0  "}ul.lst-kix_o30a3m8slal0-6{list-style-type:none}.lst-kix_o30a3m8slal0-5>li:before{content:"\0025a0  "}.lst-kix_o30a3m8slal0-4>li:before{content:"\0025cb  "}.lst-kix_o30a3m8slal0-6>li:before{content:"\0025cf  "}.lst-kix_o30a3m8slal0-3>li:before{content:"\0025cf  "}.lst-kix_o30a3m8slal0-7>li:before{content:"\0025cb  "}.lst-kix_uic5vdihm6c5-1>li:before{content:"\0025cb  "}ul.lst-kix_d8sp4n4f5mhc-0{list-style-type:none}.lst-kix_uic5vdihm6c5-0>li:before{content:"\0025cf  "}.lst-kix_uic5vdihm6c5-2>li:before{content:"\0025a0  "}.lst-kix_uic5vdihm6c5-3>li:before{content:"\0025cf  "}.lst-kix_uic5vdihm6c5-4>li:before{content:"\0025cb  "}ul.lst-kix_6c5gtkz4c1ey-5{list-style-type:none}.lst-kix_uic5vdihm6c5-5>li:before{content:"\0025a0  "}.lst-kix_uic5vdihm6c5-6>li:before{content:"\0025cf  "}ul.lst-kix_6c5gtkz4c1ey-6{list-style-type:none}ul.lst-kix_6c5gtkz4c1ey-3{list-style-type:none}ul.lst-kix_6c5gtkz4c1ey-4{list-style-type:none}ul.lst-kix_6c5gtkz4c1ey-1{list-style-type:none}ul.lst-kix_6c5gtkz4c1ey-2{list-style-type:none}ul.lst-kix_6c5gtkz4c1ey-0{list-style-type:none}.lst-kix_uic5vdihm6c5-7>li:before{content:"\0025cb  "}.lst-kix_uic5vdihm6c5-8>li:before{content:"\0025a0  "}ul.lst-kix_6c5gtkz4c1ey-7{list-style-type:none}.lst-kix_6c5gtkz4c1ey-0>li:before{content:"\0025cf  "}ul.lst-kix_6c5gtkz4c1ey-8{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c11{background-color:#ffffff;max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.c5{font-weight:700;font-family:"Courier New"}.c9{margin-left:36pt;padding-left:0pt}.c10{color:inherit;text-decoration:inherit}.c4{color:#1155cc;text-decoration:underline}.c0{orphans:2;widows:2}.c2{padding:0;margin:0}.c1{height:11pt}.c8{font-weight:700}.c7{height:16pt}.c3{page-break-after:avoid}.c6{height:20pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c11"><p class="c0 c3 title" id="h.nwvv7wugyytj"><span>Exercise: Exploring the storage layer</span></p><h1 class="c0 c3" id="h.mnuysn1tuqk5"><span>Overview</span></h1><p class="c0"><span>In this exercise you will create a schema, insert data, observe how Cassandra stores it on disk, and understand what this means for reads.</span></p><h1 class="c0 c3" id="h.j2i8kb225zwl"><span>Pre-requisites:</span></h1><ul class="c2 lst-kix_6c5gtkz4c1ey-0 start"><li class="c9 c0"><span>A working single-node Cassandra cluster (assuming that the container is called &ldquo;</span><span class="c8">cassandra-1</span><span>&rdquo;).</span></li></ul><h1 class="c0 c3" id="h.qulwwsn0w2uk"><span>Goals</span></h1><ul class="c2 lst-kix_o30a3m8slal0-0 start"><li class="c9 c0"><span>To understand how data is written to Cassandra</span></li><li class="c9 c0"><span>To understand how Cassandra manages data on-disk over time</span></li><li class="c9 c0"><span>To understand the relationship between write-behaviour and read-efficiency</span></li></ul><h1 class="c0 c3" id="h.61lry14nezh3"><span>Useful Commands</span></h1><h3 class="c0 c3" id="h.2kzs6ng7xqzn"><span>Flush data from memtables/commitlogs to disk</span></h3><p class="c0"><span class="c5">docker exec -it &lt;container-name/id&gt; nodetool flush &lt;keyspace&gt;</span></p><h3 class="c0 c3" id="h.a3mlyl58230"><span>Run &ldquo;cqlsh&rdquo; in one of your Cassandra containers</span></h3><p class="c0"><span class="c5">docker exec -it &lt;container-name/id&gt; cqlsh -C</span></p><h3 class="c0 c3" id="h.i16qrhbfuhqf"><span>Find out which files on disk are hosting a table</span></h3><p class="c0"><span class="c5">docker exec -it &lt;container-name/id&gt; sstableutil &lt;keyspace&gt; &lt;table&gt;</span></p><hr style="page-break-before:always;display:none;"><h1 class="c0 c3 c6" id="h.8bb8ja6a1wlr"><span></span></h1><h1 class="c0 c3" id="h.fqxtupeooze"><span>Steps</span></h1><h2 class="c0 c3" id="h.yqhecve8gbw8"><span>Prepare a simple schema</span></h2><p class="c0"><span>We&rsquo;ll use a very simple one-to-one table as an example schema based on a user-account database. Schema-definition and data-manipulation is done through the &ldquo;</span><span class="c8">cqlsh</span><span>&rdquo; utility (the command to run this is listed above).</span></p><h3 class="c0 c3" id="h.x3xp5f1f95ke"><span>Create a keyspace</span></h3><p class="c0"><span>This CQL statement will create a new keyspace called &ldquo;examples&rdquo; using the simple replication-strategy with one replica.</span></p><p class="c0 c1"><span></span></p><p class="c0"><span class="c5">CREATE KEYSPACE examples WITH replication = {&#39;class&#39;: &#39;SimpleStrategy&#39;, &#39;replication_factor&#39;: &#39;1&#39;};</span></p><h3 class="c0 c3" id="h.z9biwq7dzhmv"><span>Create a Table</span></h3><p class="c0"><span>This CQL statement will create a new table called &ldquo;examples&rdquo; using the simple replication-strategy with one replica.</span></p><p class="c0 c1"><span></span></p><p class="c0"><span class="c5">CREATE TABLE examples.users (</span></p><p class="c0"><span class="c5">&nbsp; user_name varchar,</span></p><p class="c0"><span class="c5">&nbsp; password varchar,</span></p><p class="c0"><span class="c5">&nbsp; country varchar,</span></p><p class="c0"><span class="c5">&nbsp; PRIMARY KEY (user_name)</span></p><p class="c0"><span class="c5">);</span></p><h3 class="c0 c3" id="h.ic0yd525z7f3"><span>Check which files are holding your data</span></h3><p class="c0"><span>You can now use the </span><span class="c8">sstableutil</span><span>&nbsp;command to check which files are holding data for your new table (of course this will return nothing right now, because you haven&rsquo;t inserted any data yet).</span></p><p class="c0 c1"><span></span></p><p class="c0"><span class="c5">docker exec -it cassandra-1 sstableutil examples users</span></p><p class="c0 c1"><span></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c1"><span></span></p><h2 class="c0 c3" id="h.7yb3nacbbyhg"><span>See some data get written to the disk</span></h2><p class="c0"><span>You will now insert some test data and see that it gets written to the disk. Again, the CQL statements are run in &ldquo;</span><span class="c8">cqlsh</span><span>&rdquo;.</span></p><h3 class="c0 c3" id="h.hect1kq56a9f"><span>Insert test data</span></h3><p class="c0"><span>Insert one user into the users table. For the benefit of further steps please use these exact values.</span></p><p class="c0 c1"><span></span></p><p class="c0"><span class="c5">INSERT INTO examples.users (user_name, password, country) VALUES (&#39;some-user&#39;, &#39;users-poor-password&#39;, &#39;uk&#39;);</span></p><h3 class="c0 c3" id="h.xcbfb5b3y9rk"><span>Check which files are holding your data</span></h3><p class="c0"><span>Use the same &ldquo;</span><span class="c8">sstableutil</span><span>&rdquo; command to list the files holding data for this table. Unless you&rsquo;ve waited a VERY long time since the previous step, there will still be no files on disk for this table. </span><span class="c8">Why has this happened?</span></p><ul class="c2 lst-kix_d8sp4n4f5mhc-0 start"><li class="c9 c0"><span>Your data is currently held </span><span class="c4"><a class="c10" href="https://www.google.com/url?q=https://wiki.apache.org/cassandra/MemtableSSTable&amp;sa=D&amp;ust=1476784017663000&amp;usg=AFQjCNFtEjvokgYmFyOZ1onDX1NCXH6eGg">in-memory</a></span><span>&nbsp;and in the </span><span class="c4"><a class="c10" href="https://www.google.com/url?q=http://wiki.apache.org/cassandra/Durability&amp;sa=D&amp;ust=1476784017664000&amp;usg=AFQjCNEsanFWpNmc622gq5_pKtMr8H_H6w">commit-logs</a></span><span>.</span></li><li class="c9 c0"><span>Time and / or throughput will eventually cause this to be flushed to an </span><span class="c4"><a class="c10" href="https://www.google.com/url?q=http://wiki.apache.org/cassandra/ArchitectureSSTable&amp;sa=D&amp;ust=1476784017664000&amp;usg=AFQjCNE5w27PWOkR10wUIyMd8u5hS6pAmA">SSTable</a></span><span>&nbsp;file.</span></li><li class="c0 c9"><span>We can also manually cause your data to be </span><span class="c4"><a class="c10" href="https://www.google.com/url?q=https://docs.datastax.com/en/cassandra/2.1/cassandra/tools/toolsFlush.html&amp;sa=D&amp;ust=1476784017665000&amp;usg=AFQjCNEpWW-Vp3e3OvOO54FPv0eOv990SQ">flushed</a></span><span>&nbsp;to disk.</span></li><li class="c9 c0"><span>Even though your data is currently not in an SSTable file it CAN still be queried - don&rsquo;t worry!</span></li></ul><h3 class="c0 c3" id="h.bav29g7xsgk4"><span>Flush your data to disk</span></h3><p class="c0"><span>Use the &ldquo;</span><span class="c8">nodetool flush</span><span>&rdquo; command to force your table to be flushed to disk, then run the &ldquo;</span><span class="c8">sstableutil</span><span>&rdquo; command again.</span></p><p class="c0 c1"><span></span></p><p class="c0"><span class="c5">docker exec -it cassandra-1 nodetool flush examples users</span></p><hr style="page-break-before:always;display:none;"><h2 class="c0 c3 c7" id="h.fz4rhbjkkigm"><span></span></h2><h2 class="c0 c3" id="h.xzdq84prgq9n"><span>See how read queries work</span></h2><p class="c0"><span>You will now have a chance to see how read-queries work against data on disk.</span></p><h3 class="c0 c3" id="h.xxroobts2c59"><span>Enable Tracing</span></h3><p class="c0"><span>CQL / cqlsh offers a powerful &ldquo;tracing&rdquo; feature (the closest to an &ldquo;explain&rdquo; query you&rsquo;ll get in Cassandra), which can show how your queries are being fulfilled and help to understand the performance implications of your queries interaction with storage.</span></p><p class="c0 c1"><span class="c8"></span></p><p class="c0"><span class="c5">TRACING ON;</span></p><h3 class="c0 c3" id="h.98l6fd2ofh91"><span>Read the data you previously inserted</span></h3><p class="c0"><span>You can now run a SELECT query in the tracing-enabled CQLSH session, paying attention to the number of SSTables involved. Of course we already know that this query will be served by one SStable.</span></p><p class="c0 c1"><span class="c8"></span></p><p class="c0"><span class="c5">SELECT * FROM examples.users WHERE user_name = &#39;some-user&#39;;</span></p><h3 class="c0 c3" id="h.8sj3qtseus44"><span>Update the record</span></h3><p class="c0"><span>Now change the password for the user we created earlier.</span></p><p class="c0 c1"><span></span></p><p class="c0"><span class="c5">UPDATE examples.users SET password = &#39;SuP3r4W3s0m3&#39; WHERE user_name = &#39;some-user&#39;;</span></p><h3 class="c0 c3" id="h.627bhum07nm5"><span>Flush the table data again</span></h3><p class="c0"><span>Use the &ldquo;</span><span class="c8">nodetool flush</span><span>&rdquo; command (in another window) to force your table to be flushed to disk, then run the &ldquo;</span><span class="c8">sstableutil</span><span>&rdquo; command again. You&rsquo;ll see that you now have 2 SSTables (and their associated metadata).</span></p><p class="c0 c1"><span></span></p><p class="c0"><span class="c5">docker exec -it cassandra-1 nodetool flush examples users</span></p><h3 class="c0 c3" id="h.rb0o03l8xc0u"><span>Read the data again</span></h3><p class="c0"><span>Run the SELECT query again in your tracing-enabled cqlsh session. It will now tell you that your single-partition read query required data to be merged from two files on disk. Congratulations - you&rsquo;ve now got an inefficient read-path.</span></p><h3 class="c0 c3" id="h.qoquwb2si2g0"><span>Use nodetool to confirm that your data is fragmented</span></h3><p class="c0 c1"><span></span></p><p class="c0"><span class="c5">docker exec -it cassandra-1 nodetool tablehistograms examples users</span></p><p class="c0 c1"><span></span></p><hr style="page-break-before:always;display:none;"><p class="c0 c1"><span></span></p><h2 class="c0 c3" id="h.ejqz6fozjl8b"><span>Re-optimising the read-path</span></h2><p class="c0"><span>You could keep updating this record (each time creating more sstables), and eventually the read performance will deteriorate. This is obviously not good! What can be done about this?</span></p><h3 class="c0 c3" id="h.n2c2owg2ff01"><span>Perform a forced compaction</span></h3><p class="c0"><span>Cassandra will periodically attempt to bring order to the fragmented chaos by concatenating SSTables together until (ideally) each partition lives entirely within one file again. These will be triggered by various thresholds, and generally it is best not to interfere with compactions (or to trigger them manually). Over-aggressive compaction can cause imbalances further down the track.</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>In this case you should trigger a manual compaction anyway, to see how it works.</span></p><p class="c0 c1"><span></span></p><p class="c0"><span class="c5">docker exec -it cassandra-1 nodetool compact examples users</span></p><p class="c0 c1"><span class="c5"></span></p><p class="c0"><span>If you run the &ldquo;</span><span class="c8">sstableutil</span><span>&rdquo; command again you will now notice that there is only one file again. It is worth noting that both of the old files (numbers 1 &amp; 2) are completely gone, replaced by number 3.</span></p><h3 class="c0 c3" id="h.6u0sjznnq54a"><span>Read the data again</span></h3><p class="c0"><span>Run the SELECT query again in your tracing-enabled cqlsh session. It will now tell you that your single-partition read query was served by one SSTable (number 3).</span></p><p class="c0 c1"><span></span></p><p class="c0"><span>Order is restored!</span></p></body></html>